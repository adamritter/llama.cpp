give me a C implementation of an example of normalizing an affine lambda expression in linear time.  The trick is to make beta reduction constant by pointing to the variable occurance from the lambda.
<think>Okay, I need to come up with a C implementation that normalizes an affine lambda expression in linear time. The key trick mentioned is making beta reduction constant time by pointing to the variable occurrence from the lambda. Let me think about how to approach this.

First, what's an affine lambda calculus? It means that each variable is used at most once. So in terms of implementation, when we perform substitutions, we don't have to worry about multiple substitutions or variable capture in the same way as the regular lambda calculus. That might simplify things.

The main challenge is to do normalization (beta reduction) in linear time. The usual problem with beta reduction is that substituting a term into another can take time proportional to the size of the term, especially if we have to traverse the term and replace variables. But if each variable is used at most once, maybe substitution can be done in constant time by just updating a pointer or something.

The user mentioned pointing to the variable occurrence from the lambda. So maybe when a lambda abstraction is applied to an argument, instead of substituting the argument into the body, we create a link from the bound variable to the argument. Then, when we encounter a variable during evaluation, we can immediately look up its value through this link without traversing the entire term.

This sounds like a form of environment-based evaluation, where instead of substituting, we keep a environment that maps variables to their values. But in affine calculus, since each variable is used once, we can maybe update the environment in place without copying, which would be efficient.

Let me sketch a data structure for lambda terms. Each term can be a variable, application, or abstraction. For variables, maybe they have a pointer to their definition if they are bound. For abstractions, when applied, the bound variable's pointer is set to the argument, and then the body is evaluated in this context.

Wait, but in C, how do we represent terms? Let's think in terms of structs. Maybe each term has a type (var, app, abs), and for variables, they have a reference to their binder or the substituted value. For example:

typedef enum { VAR, APP, ABS } TermType;

struct Term {

TermType type;

union {

struct { // VAR

struct Term *binding; // Points to the argument if substituted

};

struct { // APP

struct Term *func;

struct Term *arg;

};

struct { // ABS

struct Term *body;

struct Term *param; // Maybe track the parameter here?

};

};

};

But I'm not sure. Another approach: When a lambda is applied, the variable it binds is linked directly to the argument. So during evaluation, whenever we encounter a variable, we check if it's bound to a value (i.e., if it's been substituted via a beta-redex). If so, we replace it with that value.

But in affine lambda calculus, each variable is used at most once, so once we substitute, we can "consume" the variable, meaning we don't have to worry about multiple substitutions. That allows us to destructively update the variable's pointer to its value, which is safe because it's only used once.

So the idea is: when you apply a lambda (ABS) to an argument, you take the parameter (variable) of the lambda and set its binding to the argument. Then, when you evaluate the body of the lambda, any reference to the variable will immediately dereference to the argument. Since the variable is affine (used at most once), this pointer can be safely overwritten without affecting other parts of the term.

But how do variables know their binding? Maybe variables are represented with a pointer that can be updated. Let's consider:

Each variable is a node that may have a "target" pointer. Initially, variables in abstractions point to their binder (or maybe nothing, but during application, the binder's variable is set to point to the argument). When evaluating a variable, if it has a target, we follow it; otherwise, it's a free variable.

Wait, maybe when we create a lambda abstraction, the parameter is a variable node. When the lambda is applied to an argument, the parameter's target is set to the argument. Then, when we encounter the parameter in the body, we just follow the target pointer, which gives us the argument. Since the parameter is affine, this happens only once, so the target pointer is only followed once.

But in code, how does this work? Let's try to model it.

Let me think step by step:

1. Represent the lambda term as a graph where variables can point to their values (if substituted) or be unbound.

2. When evaluating an application (APP node), we check if the function is an ABS. If so, we take the ABS's parameter (a VAR node) and set its binding to the argument. Then we evaluate the ABS's body. Since the parameter is affine, we don't need to copy the argument; just point the parameter to it.

3. When evaluating a VAR node, if it has a binding, we replace it with the value of the binding. But since it's affine, once we use it, maybe we can set the binding to NULL to prevent reuse, but in affine terms, this should not happen.

Wait, but affine terms allow variables to be used zero or once. So during evaluation, when we encounter a variable that has a binding (i.e., was part of a beta-redex), we replace it with the argument. However, since in affine calculus, the variable can be used at most once, this replacement will only happen once. So the pointer can be safely followed, and after that, the variable is effectively gone because it's been replaced.

So the key is that substitution is done by pointer manipulation. Instead of copying the argument into every occurrence of the variable (which would take O(n) time), we just set the variable's pointer to the argument. Then, when the variable is encountered during evaluation, we immediately dereference it. Since the variable is only used once (due to affine restriction), this is safe and takes constant time.

So the normalization process is just evaluating the term step by step, using these pointer updates for substitutions.

Now, how to model this in C.

Let's define the term structure. Each term can be a variable, application, or abstraction. Variables can have a "value" pointer that, if non-NULL, points to their substituted term. When a variable is substituted (i.e., during beta reduction), its value pointer is set to the argument. When evaluating a variable, if it has a value, we evaluate that value instead.

But in C, when we have a variable that points to another term, we need to make sure that when we traverse the term, we follow these pointers. So during evaluation, whenever we encounter a variable, we check if it's bound (has a value). If so, we replace it with the value. But since variables are affine, each substitution is used exactly once, so after replacing, maybe we can set the variable's value to NULL to prevent reuse. But since the term is affine, there shouldn't be any other references to that variable.

Wait, but affine terms allow variables to be used zero or once. So during substitution, the variable is used once. So once we substitute, the variable's value is consumed, and further uses would be invalid. But in the implementation, since the term is affine, the code can assume that variables are used at most once, so substitution can be done destructively.

So here's a possible approach:

- Variables are represented with a pointer to their value (initially NULL).

- When a lambda is applied to an argument, the parameter variable's value is set to the argument. Then, the body is evaluated. Any occurrence of the parameter in the body will now point to the argument.

- When evaluating a variable, if it has a value, we evaluate the value instead.

But since evaluation is done in a way that each variable is only encountered once (due to affine usage), this is safe.

But how does the evaluation proceed? Let's model normalization as a function that takes a term and returns its normal form.

Wait, but in lambda calculus, the normal form is reached by repeatedly applying beta reduction until no more can be applied. To do this in linear time, the key is that each beta reduction is done in constant time, and the total number of reductions is linear in the size of the term.

In the affine case, since each beta redex is used at most once, perhaps the number of reductions is bounded by the number of nodes in the term, leading to linear time overall.

So, the algorithm would traverse the term, applying beta reductions as they are encountered, and updating the pointers to substitute variables. Each substitution is O(1) because it's just a pointer assignment, and each variable is substituted at most once.

Now, let's think about the data structures again.

Each term is a struct:

typedef enum { VAR, APP, ABS } TermType;

struct Term {

TermType type;

union {

struct { // VAR

struct Term *value; // If substituted, points to the argument

};

struct { // APP

struct Term *func;

struct Term *arg;

};

struct { // ABS

struct Term *param; // The parameter variable (type VAR)

struct Term *body;

};

};

};

But wait, in the ABS case, the parameter is a variable. So when creating an abstraction, we need to create a variable node as the parameter.

So, for example, the term λx. x would be an ABS node with param pointing to a VAR node (x), and body pointing to the same VAR node.

Then, when we apply this ABS to an argument, say, M, the application node (APP) has func as the ABS and arg as M. Evaluating this application would set the param's value to M and then evaluate the body. The body is x, which now has value pointing to M. So evaluating x would replace it with M.

But how do we handle nested applications and abstractions? For example, (λx. x) (λy. y). The application would set x's value to λy.y. Then evaluating x (the body) gives λy.y, which is in normal form.

But the key is that substitution is done by pointer manipulation. When evaluating a term, we need to traverse it, replacing variables with their values if available.

But how do we avoid re-evaluating the same terms multiple times? Maybe we evaluate terms in a way that once a term is evaluated, its structure is updated to reflect its normal form. This is similar to graph reduction, where shared subterms are updated in place.

But for linear time, each node is processed a constant number of times.

So, the normalization function would traverse the term, and whenever it encounters an application of an abstraction, perform the substitution by setting the parameter's value to the argument and then proceeding to evaluate the body. Other structures (like nested applications) are processed recursively.

But to ensure this is done in linear time, each node is visited a constant number of times. Let's outline the steps:

1. Start with the root term.

2. Traverse the term, evaluating as we go.

3. For an APP node, first evaluate the function. If the function becomes an ABS after evaluation, then substitute the argument into the ABS's body by setting the parameter's value to the evaluated argument. Then evaluate the body.

4. For an ABS node, evaluate the body (since the body might contain applications that need to be reduced).

5. For a VAR node, if it has a value, replace it with the evaluated value of that value.

But variables can be part of larger terms. Wait, perhaps the evaluation is done in a way that whenever we encounter a node, we reduce it as much as possible.

Alternatively, we can model evaluation as follows:

struct Term* eval(struct Term* t) {

if (t == NULL) return t;

switch (t->type) {

case VAR: {

// If the variable has a value, evaluate it

if (t->value != NULL) {

struct Term* val = eval(t->value);

// Replace the variable with its value

// But how? Since variables can't be modified (struct is immutable?), perhaps we need a different approach.

// Wait, in the previous idea, variables have a 'value' pointer that is set during substitution.

// So, when evaluating a variable, if it has a value, we return the evaluated value.

// But this would mean that variables are like indirections.

// However, in C, we can't replace the variable node itself, but perhaps we can follow the chain.

// So evaluating a variable would return eval(t->value), but if t->value is NULL, return t.

if (t->value) {

return eval(t->value);

} else {

return t;

}

}

break;

}

case APP: {

struct Term* func = eval(t->func);

if (func->type == ABS) {

// Substitute the argument into the abstraction's body

struct Term* arg = eval(t->arg);

// Set the parameter's value to the evaluated argument

func->param->value = arg;

// Evaluate the body of the abstraction, which now has the parameter's value set

struct Term* result = eval(func->body);

// Reset the parameter's value to NULL for potential future use? But affine, so should not be reused.

// But since it's affine, after substitution, the parameter is used once, so no need to reset.

return result;

} else {

// The function doesn't reduce, so return the application of evaluated func and arg

t->func = func;

t->arg = eval(t->arg);

return t;

}

break;

}

case ABS: {

// Evaluate the body in case there are reducible expressions inside

t->body = eval(t->body);

return t;

}

}

return t;

}

Wait, but this code has some issues. For example, when evaluating an application, if the function is an abstraction, we substitute the argument into the body and then evaluate the body. But after substitution, the parameter's value is set to the evaluated argument. Then, when the body is evaluated, any occurrence of the parameter will be replaced with the argument.

But this approach may not handle nested substitutions correctly. Also, variables in the argument could themselves be bound to other terms.

Another problem is that when we set func->param->value = arg, we are modifying the abstraction's parameter. If the same abstraction is used in multiple places (though in affine calculus, this might not be allowed), but affine calculus allows linear use, so each abstraction is applied at most once. So in the affine case, applying an abstraction more than once would be invalid, but the type system (affine) ensures that doesn't happen. So in the implementation, we can assume that each abstraction is applied at most once, so setting the parameter's value is safe.

But in the code above, after substitution, the parameter's value is set, and subsequent evaluations of the body will use that value. However, if the body is part of a larger term that is evaluated again, this could cause issues. But in normalization, once a term is evaluated, it's in normal form and shouldn't be re-evaluated.

But wait, the eval function as written is not in-place. When evaluating an application, it creates a new term? No, in the code above, it modifies the parameter's value pointer. So it's a graph reduction approach where the original term is modified. But in C, if the term is shared in multiple places, this could lead to unintended side effects. However, affine lambda calculus's linearity ensures that terms are used at most once, so sharing isn't a problem.

Another thing to note: when we substitute an argument into an abstraction, we must evaluate the argument first. That's captured by evaluating t->arg before setting the parameter's value.

But in the code, after substituting, we evaluate the body. But the body may contain other applications, which are handled recursively.

But how does this ensure linear time? Each node is processed a constant number of times. For example, each application is processed once, and each variable is dereferenced once.

However, the code as written may not be tail-recursive and could lead to multiple traversals. To achieve linear time, we need an iterative approach or ensure that each node is visited once.

Alternatively, using a pointer-based approach with closures, where substitutions are done via environment links, and variables are just pointers into the environment. But I'm not sure.

Another approach is to use a "spine" traversal, where we process applications by building a stack of arguments and then applying them to the function once it's a lambda.

But I'm not sure. Let's think of an example.

Consider the term (λx. x) (λy. y) (λz. z). Wait, no, in affine calculus, variables must be used at most once. But this example is an application of two arguments, which may not be allowed. Let's take a simpler example: (λx. x) M. The normal form is M.

In the code, evaluating the application would evaluate M, set x's value to M, then evaluate x's body (which is x). Evaluating x would then return M's evaluated form.

So in code:

1. Eval the APP node.

2. Eval the func, which is ABS.

3. Eval the arg, which is M.

4. Set ABS's param (x) value to evaluated M.

5. Eval the body (x) which now points to M, so return M's evaluated form.

This seems correct.

Another example: (λx. λy. x) M N. But in affine calculus, x is used once (in the body λy.x), and y is unused. So the term would reduce to λy.M. But applying this would substitute M for x.

In code:

Eval the outer APP ( (λx. λy. x M) N )? Wait, the term is ((λx. (λy. x)) M) N. Evaluating the first application (func=λx.λy.x, arg=M):

- Eval func (it's ABS).

- Eval arg M (result M_eval).

- Set x's value to M_eval.

- Eval body, which is λy.x. Since x's value is M_eval, but the body is an ABS. So evaluating the ABS would evaluate its body (x). But when we create the ABS λy.x, the x here is now pointing to M_eval. So the result is λy.M_eval. Then, the next application to N would apply this, but since the outer term is ((λx.λy.x) M) N, the first application reduces to λy.M, then applying to N would reduce to M (since λy.M N → M if y is not free in M, which in affine calculus y is not used).

But how does the code handle this? Let's walk through it.

First, the initial term is APP(APP(ABS(x, ABS(y, VAR(x))), M), N).

Evaluating the first APP:

- func is ABS(x, ...), arg is M.

- Eval M to M_eval.

- Set x's value to M_eval.

- Eval body: ABS(y, VAR(x)).

When evaluating the ABS(y, VAR(x)), we evaluate VAR(x). Since x's value is M_eval, evaluating VAR(x) returns M_eval. But the body of the inner ABS is VAR(x), which is M_eval. So the result of evaluating the body is ABS(y, M_eval)? No, because when we evaluate an ABS, we evaluate its body. But in the code above, when evaluating an ABS, we evaluate the body and then return the ABS. Wait, in the code:

case ABS: {

t->body = eval(t->body);

return t;

}

So evaluating an abstraction evaluates its body. So in the example, the outer ABS(x, ABS(y, VAR(x))) when applied to M becomes:

After substitution, x's value is M_eval. Then evaluating the body of the outer ABS, which is ABS(y, VAR(x)). Evaluating this ABS involves evaluating its body (VAR(x)).

VAR(x) is evaluated by looking at x->value, which is M_eval, so VAR(x) evaluates to M_eval. Then the body of the inner ABS becomes M_eval? No, wait: the inner ABS's body is VAR(x). When we evaluate this ABS, we replace its body with the result of evaluating VAR(x), which is M_eval. So the inner ABS becomes ABS(y, M_eval). Then, this is returned as the result of the first application.

Then, the overall term becomes APP(ABS(y, M_eval), N). Evaluating this application:

- Eval func (ABS(y, M_eval)), eval arg N to N_eval.

- Set y's value to N_eval.

- Evaluate body M_eval. Since M_eval is already evaluated (assuming M was in normal form), returns M_eval.

So the final result is M_eval, which is correct.

But in this case, the inner ABS's body was a variable x, which was substituted to M_eval. But in the code, when evaluating the inner ABS, we evaluate its body (VAR(x)), which then points to M_eval, so the body becomes M_eval, and the ABS node's body is updated to M_eval. Wait, but in the code, the ABS's body is set to eval(t->body). So if the body was VAR(x), then eval(VAR(x)) would return M_eval, so the ABS node's body is set to M_eval. But then the ABS node becomes a term whose body is M_eval, which is not an abstraction anymore. That's a problem.

Wait, this suggests a flaw in the code. Because if the body of an abstraction is evaluated to a non-abstraction term, then the abstraction itself would be modified incorrectly.

Wait, no. In lambda calculus, the body of an abstraction is a term, but the abstraction itself is a value unless it's applied. So evaluating an abstraction should not evaluate its body unless it's being applied. But in the code above, when an ABS node is evaluated, the code evaluates its body. That's incorrect because the body of an abstraction is only evaluated when the abstraction is applied.

Ah, here's the mistake. The code as written evaluates the body of an abstraction when the abstraction itself is evaluated, which is not correct. The body of an abstraction should only be evaluated when the abstraction is applied to an argument. So the code for the ABS case should not evaluate the body immediately.

So the correction is: when evaluating an ABS, do not evaluate its body. The body is only evaluated when the abstraction is applied.

So, in the code:

case ABS: {

// Do not evaluate the body here; only when the abstraction is applied.

return t;

}

Then, when the abstraction is applied, we substitute the argument into the body and evaluate the body.

This changes the earlier example. Let's re-examine the term (λx. λy. x) M.

Evaluating the application:

1. func is λx. λy. x. Evaluating this (as ABS) returns the same ABS.

2. arg is M, evaluate to M_eval.

3. Set x's value to M_eval.

4. Evaluate the body of the abstraction, which is λy. x. Now, evaluating this ABS (λy. x) would return it as is, because evaluating an ABS does not evaluate its body. So the result of the application is λy. x, but x's value is M_eval.

But when we later apply this result to N, we get:

The application (λy. x) N. Evaluating this:

1. Evaluate func (λy. x) which is an ABS.

2. Evaluate arg N to N_eval.

3. Set y's value to N_eval.

4. Evaluate the body of the ABS, which is x. Now, x's value is M_eval, so evaluating x returns M_eval.

5. So the result is M_eval.

But in the code, when evaluating the application (λy.x) N, the body is x, which has value M_eval. So the result is M_eval.

But how is this captured in the code? Let's correct the code.

The corrected eval function:

struct Term* eval(struct Term* t) {

if (t == NULL) return t;

switch (t->type) {

case VAR: {

if (t->value != NULL) {

// If the variable has a value, evaluate it

return eval(t->value);

} else {

return t;

}

}

case APP: {

struct Term* func = eval(t->func);

if (func->type == ABS) {

struct Term* arg = eval(t->arg);

func->param->value = arg;

struct Term* result = eval(func->body);

// Optionally, reset the param's value to NULL if needed, but affine so shouldn't matter

return result;

} else {

// The function didn't reduce to an abstraction, so just return the evaluated application

t->func = func;

t->arg = eval(t->arg);

return t;

}

}

case ABS: {

// Do not evaluate the body here

return t;

}

}

return t;

}

In this version, when an ABS is evaluated, it's returned as is. Only when it's applied (in the APP case) is its body evaluated. This seems correct.

Now, let's test this with the previous example:

Term structure for (λx. λy. x) M:

- APP node with func=ABS(x, ABS(y, VAR(x))), arg=M.

Evaluating APP:

- func is evaluated to ABS(x, ...).

- arg is evaluated to M_eval.

- Set x's value to M_eval.

- Evaluate func->body, which is ABS(y, VAR(x)).

Evaluating ABS(y, VAR(x)) returns it as is (since ABS case doesn't evaluate body). So the result is ABS(y, VAR(x)), but x's value is M_eval.

Then, applying this to N:

- APP node with func=ABS(y, VAR(x)), arg=N.

Evaluating this APP:

- func is ABS(y, ...).

- arg evaluated to N_eval.

- Set y's value to N_eval.

- Evaluate func->body, which is VAR(x).

Evaluating VAR(x): x's value is M_eval, so returns eval(M_eval).

Assuming M_eval is in normal form, returns M_eval.

Thus, the overall result is M_eval, which is correct.

Another test case: (λx. x x) would not be allowed in affine calculus because x is used twice. But the affine check is not handled by this code. The code assumes that terms are affine, so the user must ensure that variables are used at most once.

Now, about the time complexity. Each beta reduction (application of ABS to arg) is O(1) because it's just pointer assignments. Each variable dereference is O(1) because we follow the pointer once. Each node is processed a constant number of times. For example, each application is processed once (when it's the top-level term or after its function is evaluated). Variables are dereferenced once. So overall, the time complexity is linear in the size of the term.

But how do we ensure that each node is visited a linear number of times? Let's consider the number of eval calls for each node.

- For a VAR node: when evaluated, if it has a value, it calls eval on the value. So if the value is another term, it processes that term. But since each substitution is done once (due to affine), each VAR node is processed at most twice: once when it's substituted (as a parameter), and once when it's evaluated.

But perhaps more accurately, each node is processed once for each time it's encountered in the eval traversal. However, because of the pointer redirects, some paths are shortcut. For example, a VAR node with a value will redirect to its value immediately, so subsequent evaluations of that VAR node (if any, but in affine there shouldn't be) would follow the value.

But in affine terms, variables are used at most once, so each VAR node is evaluated at most once. Thus, the total number of eval calls is proportional to the number of nodes in the original term.

Therefore, the algorithm runs in linear time.

Now, implementing this in C.

We need to define the Term struct, and functions to create variables, applications, and abstractions.

But in C, we need to manage memory. However, for the sake of the example, maybe we can ignore deallocation and focus on the reduction.

First, the Term struct:

#include <stdlib.h>

#include <stdio.h>

typedef enum TermType { VAR, APP, ABS } TermType;

struct Term {

TermType type;

union {

struct { // VAR

struct Term *value;

};

struct { // APP

struct Term *func;

struct Term *arg;

};

struct { // ABS

struct Term *param;

struct Term *body;

};

};

};

typedef struct Term Term;

Term* new_var() {

Term* t = (Term*)malloc(sizeof(Term));

t->type = VAR;

t->value = NULL;

return t;

}

Term* new_app(Term* func, Term* arg) {

Term* t = (Term*)malloc(sizeof(Term));

t->type = APP;

t->func = func;

t->arg = arg;

return t;

}

Term* new_abs(Term* param, Term* body) {

Term* t = (Term*)malloc(sizeof(Term));

t->type = ABS;

t->param = param;

t->body = body;

return t;

}

Term* eval(Term* t) {

if (!t) return t;

switch (t->type) {

case VAR:

if (t->value) {

Term* val = eval(t->value);

return val;

} else {

return t;

}

case APP: {

Term* func = eval(t->func);

if (func->type == ABS) {

Term* arg = eval(t->arg);

func->param->value = arg;

Term* result = eval(func->body);

return result;

} else {

t->func = func;

t->arg = eval(t->arg);

return t;

}

}

case ABS:

return t;

}

return t;

}

// Example usage:

int main() {

// Create the term (λx. x) (λy. y)

Term* x = new_var();

Term* id_x = new_abs(x, x);

Term* y = new_var();

Term* id_y = new_abs(y, y);

Term* app = new_app(id_x, id_y);

Term* result = eval(app);

// The result should be id_y (λy.y)

printf("Result type: %s\n", result->type == ABS ? "ABS" : "OTHER");

// Cleanup (not necessary for the example, but good practice)

free(x);

free(id_x);

free(y);

free(id_y);

free(app);

free(result);

return 0;

}

Wait, but in this example, x and y are variables. The term (λx.x) (λy.y) should reduce to λy.y.

But in the code, when we create id_x as new_abs(x, x), then app is new_app(id_x, id_y). Evaluating app:

- Eval func: id_x is ABS, so evaluate to itself.

- Eval arg: id_y is ABS, evaluates to itself.

- Set x's value to id_y.

- Eval func->body (x), which is x. Since x's value is id_y, eval returns id_y.

So the result should be id_y, which is of type ABS. The printf should output "ABS".

But in the current code, when we create id_x as new_abs(x, x), the x is a variable. The application new_app(id_x, id_y) will, when evaluated, set x's value to id_y (which is an ABS node). Then eval(x) will return id_y.

So the result is id_y, which is correct.

But in the code, when we free(x), but x is part of the id_x abstraction. However, after substitution, x's value is set to id_y. However, this code is just an example and doesn't handle memory correctly, but for the sake of illustration, it works.

This code demonstrates the key idea: beta reduction is done by setting the parameter's value pointer to the argument, and then evaluating the body, which uses the parameter's value. Each substitution is O(1), and each variable is evaluated at most once, leading to linear time normalization for affine terms.

Potential issues:

- Memory management is not handled properly. For example, after substitution, the original terms may still have pointers to old structures. However, in affine calculus, terms are used linearly, so once a substitution is done, the old terms are not accessed again.

- The code assumes that variables are only used once, as per affine rules. If a variable is used multiple times, the code may have undefined behavior (like accessing freed memory or invalid pointers).

- The eval function is recursive and may cause stack overflow for large terms. An iterative implementation would be better, but for the example, recursion is simpler.

But the main goal was to show an example of normalization in linear time using pointer manipulation for substitutions, which this code illustrates.

</think>
To normalize an affine lambda expression in linear time, we can leverage the affine nature (each variable used at most once) to perform beta reductions via pointer updates rather than explicit substitutions. Here's a C implementation:

```c
#include <stdlib.h>
#include <stdio.h>

typedef enum TermType { VAR, APP, ABS } TermType;

typedef struct Term {
    TermType type;
    union {
        struct { // VAR
            struct Term *value;
        };
        struct { // APP
            struct Term *func;
            struct Term *arg;
        };
        struct { // ABS
            struct Term *param;
            struct Term *body;
        };
    };
} Term;

Term* new_var() {
    Term* t = (Term*)malloc(sizeof(Term));
    t->type = VAR;
    t->value = NULL;
    return t;
}

Term* new_app(Term* func, Term* arg) {
    Term* t = (Term*)malloc(sizeof(Term));
    t->type = APP;
    t->func = func;
    t->arg = arg;
    return t;
}

Term* new_abs(Term* param, Term* body) {
    Term* t = (Term*)malloc(sizeof(Term));
    t->type = ABS;
    t->param = param;
    t->body = body;
    return t;
}

Term* eval(Term* t) {
    if (!t) return t;
    switch (t->type) {
        case VAR:
            if (t->value) {
                Term* val = eval(t->value);
                return val;
            } else {
                return t;
            }
        case APP: {
            Term* func = eval(t->func);
            if (func->type == ABS) {
                Term* arg = eval(t->arg);
                func->param->value = arg;
                Term* result = eval(func->body);
                return result;
            } else {
                t->func = func;
                t->arg = eval(t->arg);
                return t;
            }
        }
        case ABS:
            return t;
    }
    return t;
}

// Example: (λx.x)(λy.y) → λy.y
int main() {
    Term* x = new_var();
    Term* id_x = new_abs(x, x);
    Term* y = new_var();
    Term* id_y = new_abs(y, y);
    Term* app = new_app(id_x, id_y);
    
    Term* result = eval(app);
    printf("Result type: %s\n", result->type == ABS ? "ABS" : "OTHER");

    // Cleanup (simplified)
    free(x); free(id_x); free(y); free(id_y); free(app); free(result);
    return 0;
}
'''

Explanation:

Term Structure:

VAR: Contains a value pointer to its substituted term.

APP: Represents function application with func and arg.

ABS: Lambda abstraction with param (a VAR) and body.

Beta Reduction:

When evaluating an application (APP), if the function is an abstraction (ABS), the parameter's value is set to the evaluated argument.

The body of the abstraction is then evaluated in this context.

Affine Handling:

Since each variable is used at most once, updating the value pointer is safe and avoids copying.

Evaluation:

Variables dereference their value if available.

Applications reduce if the function is an abstraction, otherwise they are left as-is.

Abstractions are considered normal forms unless applied.

Key Insight:
By using pointer indirection for substitutions and leveraging affine variable usage, each beta reduction occurs in constant time, leading to linear overall normalization time relative to the term size.

